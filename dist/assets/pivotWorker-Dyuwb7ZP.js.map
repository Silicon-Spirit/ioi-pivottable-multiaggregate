{"version":3,"file":"pivotWorker-Dyuwb7ZP.js","sources":["../src/utils/utils.js","../src/utils/pivotEngine.js","../src/worker/pivotWorker.js"],"sourcesContent":["// Helper function to get translation function\nconst getTranslation = () => {\n\tif (typeof window !== 'undefined' && window.__) {\n\t\treturn window.__;\n\t}\n\t// Fallback if __ is not available\n\treturn (text, args) => {\n\t\tif (args && args.length) {\n\t\t\treturn text.replace(/\\{(\\d+)\\}/g, (match, index) => args[parseInt(index)] || match);\n\t\t}\n\t\treturn text;\n\t};\n};\n\nconst __ = getTranslation();\n\nconst addSeparators = function (nStr, thousandsSep, decimalSep) {\n\tconst x = String(nStr).split(\".\");\n\tlet x1 = x[0];\n\tconst x2 = x.length > 1 ? decimalSep + x[1] : \"\";\n\tconst rgx = /(\\d+)(\\d{3})/;\n\twhile (rgx.test(x1)) {\n\t\tx1 = x1.replace(rgx, `$1${thousandsSep}$2`);\n\t}\n\treturn x1 + x2;\n};\n\nconst getFormatOptionsFromFrappe = () => {\n\t// Web Workers don't have access to window object\n\tif (typeof window === 'undefined' || !window.get_number_format || !window.get_number_format_info) {\n\t\t// Return default format options for worker context or when window functions are unavailable\n\t\treturn {\n\t\t\tthousandsSep: ',',\n\t\t\tdecimalSep: '.',\n\t\t\tdigitsAfterDecimal: 2,\n\t\t};\n\t}\n\t\n\tconst format = window.get_number_format();\n\tconst format_info = window.get_number_format_info(format)\n\n\treturn {\n\t\tthousandsSep: format_info.group_sep,\n\t\tdecimalSep: format_info.decimal_str,\n\t\tdigitsAfterDecimal: format_info.precision,\n\t};\n};\n\nconst numberFormat = function (optsIn) {\n\tconst frappeFormat = getFormatOptionsFromFrappe();\n\tconst defaults = {\n\t\tdigitsAfterDecimal: frappeFormat.digitsAfterDecimal,\n\t\tscaler: 1,\n\t\tthousandsSep: frappeFormat.thousandsSep,\n\t\tdecimalSep: frappeFormat.decimalSep,\n\t\tprefix: \"\",\n\t\tsuffix: \"\",\n\t};\n\tconst opts = Object.assign({}, defaults, optsIn);\n\treturn function (x) {\n\t\tif (isNaN(x) || !isFinite(x)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst result = addSeparators(\n\t\t\t(opts.scaler * x).toFixed(opts.digitsAfterDecimal),\n\t\t\topts.thousandsSep,\n\t\t\topts.decimalSep\n\t\t);\n\t\treturn `${opts.prefix}${result}${opts.suffix}`;\n\t};\n};\n\nconst rx = /(\\d+)|(\\D+)/g;\nconst rd = /\\d/;\nconst rz = /^0/;\nconst naturalSort = (as, bs) => {\n\t// nulls first\n\tif (bs !== null && as === null) {\n\t\treturn -1;\n\t}\n\tif (as !== null && bs === null) {\n\t\treturn 1;\n\t}\n\n\t// then raw NaNs\n\tif (typeof as === \"number\" && isNaN(as)) {\n\t\treturn -1;\n\t}\n\tif (typeof bs === \"number\" && isNaN(bs)) {\n\t\treturn 1;\n\t}\n\n\t// numbers and numbery strings group together\n\tconst nas = Number(as);\n\tconst nbs = Number(bs);\n\tif (nas < nbs) {\n\t\treturn -1;\n\t}\n\tif (nas > nbs) {\n\t\treturn 1;\n\t}\n\n\t// within that, true numbers before numbery strings\n\tif (typeof as === \"number\" && typeof bs !== \"number\") {\n\t\treturn -1;\n\t}\n\tif (typeof bs === \"number\" && typeof as !== \"number\") {\n\t\treturn 1;\n\t}\n\tif (typeof as === \"number\" && typeof bs === \"number\") {\n\t\treturn 0;\n\t}\n\n\t// 'Infinity' is a textual number, so less than 'A'\n\tif (isNaN(nbs) && !isNaN(nas)) {\n\t\treturn -1;\n\t}\n\tif (isNaN(nas) && !isNaN(nbs)) {\n\t\treturn 1;\n\t}\n\n\t// finally, \"smart\" string sorting per http://stackoverflow.com/a/4373421/112871\n\tlet a = String(as);\n\tlet b = String(bs);\n\tif (a === b) {\n\t\treturn 0;\n\t}\n\tif (!rd.test(a) || !rd.test(b)) {\n\t\treturn a > b ? 1 : -1;\n\t}\n\n\t// special treatment for strings containing digits\n\ta = a.match(rx);\n\tb = b.match(rx);\n\twhile (a.length && b.length) {\n\t\tconst a1 = a.shift();\n\t\tconst b1 = b.shift();\n\t\tif (a1 !== b1) {\n\t\t\tif (rd.test(a1) && rd.test(b1)) {\n\t\t\t\treturn a1.replace(rz, \".0\") - b1.replace(rz, \".0\");\n\t\t\t}\n\t\t\treturn a1 > b1 ? 1 : -1;\n\t\t}\n\t}\n\treturn a.length - b.length;\n};\nconst sortAs = function (order) {\n\tconst mapping = {};\n\n\t// sort lowercased keys similarly\n\tconst lMapping = {};\n\tfor (const i in order) {\n\t\tconst x = order[i];\n\t\tmapping[x] = i;\n\t\tif (typeof x === \"string\") {\n\t\t\tlMapping[x.toLowerCase()] = i;\n\t\t}\n\t}\n\treturn function (a, b) {\n\t\tif (a in mapping && b in mapping) {\n\t\t\treturn mapping[a] - mapping[b];\n\t\t} else if (a in mapping) {\n\t\t\treturn -1;\n\t\t} else if (b in mapping) {\n\t\t\treturn 1;\n\t\t} else if (a in lMapping && b in lMapping) {\n\t\t\treturn lMapping[a] - lMapping[b];\n\t\t} else if (a in lMapping) {\n\t\t\treturn -1;\n\t\t} else if (b in lMapping) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn naturalSort(a, b);\n\t};\n};\n\nconst getSort = function (sorters, attr) {\n\tif (sorters) {\n\t\tif (typeof sorters === \"function\") {\n\t\t\tconst sort = sorters(attr);\n\t\t\tif (typeof sort === \"function\") {\n\t\t\t\treturn sort;\n\t\t\t}\n\t\t} else if (attr in sorters) {\n\t\t\treturn sorters[attr];\n\t\t}\n\t}\n\treturn naturalSort;\n};\n\n// aggregator templates default to US number formatting but this is overrideable\nconst usFmt = numberFormat();\nconst usFmtInt = numberFormat({ digitsAfterDecimal: 0 });\nconst usFmtPct = numberFormat({\n\tdigitsAfterDecimal: 1,\n\tscaler: 100,\n\tsuffix: \"%\",\n});\n\nconst aggregatorTemplates = {\n\tcount(formatter = usFmtInt) {\n\t\treturn () =>\n\t\t\tfunction (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tpush() {\n\t\t\t\t\t\tthis.count++;\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\treturn this.count;\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: 0,  // âœ… Add this: Count doesn't need any value fields\n\t\t\t\t};\n\t\t\t};\n\t},\n\n\tuniques(fn, formatter = usFmtInt) {\n\t\treturn function ([attr]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\t// Store attr in closure so it's accessible in push method\n\t\t\t\tconst attrName = attr;\n\t\t\t\treturn {\n\t\t\t\t\tuniq: [],\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Standard pivot table behavior for List Unique Values:\n\t\t\t\t\t\t// 1. If attr is undefined/null, skip this record (no attribute to collect)\n\t\t\t\t\t\t// 2. If attr is defined, get record[attr] (even if undefined/null - those are valid unique values)\n\t\t\t\t\t\tif (attrName === undefined || attrName === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the value from the record (can be any type including undefined, null, NaN, objects)\n\t\t\t\t\t\tconst value = record[attrName];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check if this value is already in the unique array\n\t\t\t\t\t\t// Standard implementation uses strict equality with special handling for NaN\n\t\t\t\t\t\tlet isUnique = true;\n\t\t\t\t\t\tfor (let i = 0; i < this.uniq.length; i++) {\n\t\t\t\t\t\t\tconst existing = this.uniq[i];\n\t\t\t\t\t\t\t// Special case: NaN comparison (NaN !== NaN in JavaScript)\n\t\t\t\t\t\t\tif (typeof value === 'number' && typeof existing === 'number' && isNaN(value) && isNaN(existing)) {\n\t\t\t\t\t\t\t\tisUnique = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Standard strict equality check\n\t\t\t\t\t\t\t// This handles: null, undefined, primitives, objects (by reference)\n\t\t\t\t\t\t\tif (value === existing) {\n\t\t\t\t\t\t\t\tisUnique = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Add the value if it's unique\n\t\t\t\t\t\t// Note: null, undefined, NaN, and objects are all valid unique values\n\t\t\t\t\t\tif (isUnique) {\n\t\t\t\t\t\t\tthis.uniq.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// Expose uniq array for debugging\n\t\t\t\t\tgetUniqArray() {\n\t\t\t\t\t\treturn this.uniq;\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\t// Ensure we return the result of fn applied to the unique array\n\t\t\t\t\t\t// For listUnique, fn is (x) => x.join(\", \"), so this returns a comma-separated string\n\t\t\t\t\t\tif (this.uniq && this.uniq.length > 0 && typeof fn === 'function') {\n\t\t\t\t\t\t\tconst result = fn(this.uniq);\n\t\t\t\t\t\t\t// Debug: log for List Unique Values aggregators\n\t\t\t\t\t\t\tif (attrName && this.uniq.length > 0) {\n\t\t\t\t\t\t\tconst isListUnique = typeof result === 'string' && result.includes(',');\n\t\t\t\t\t\t\tif (isListUnique || (this.uniq.length === 1 && attrName.includes('mark'))) {\n\t\t\t\t\t\t\t\t// Debug info for List Unique Values aggregator\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fallback: if uniq is empty or fn is not a function, return empty string\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: typeof attrName !== \"undefined\" ? 0 : 1,\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\tsum(formatter = usFmt) {\n\t\treturn function ([attr]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tsum: 0,\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Handle undefined attr gracefully\n\t\t\t\t\t\tif (attr === undefined || attr === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst value = record[attr];\n\t\t\t\t\t\tif (value !== undefined && value !== null && !isNaN(parseFloat(value))) {\n\t\t\t\t\t\t\tthis.sum += parseFloat(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\treturn this.sum;\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: typeof attr !== \"undefined\" ? 0 : 1,\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\textremes(mode, formatter = usFmt) {\n\t\treturn function ([attr]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tval: null,\n\t\t\t\t\tsorter: getSort(\n\t\t\t\t\t\ttypeof data !== \"undefined\" ? data.sorters : null,\n\t\t\t\t\t\tattr\n\t\t\t\t\t),\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Handle undefined attr gracefully\n\t\t\t\t\t\tif (attr === undefined || attr === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet x = record[attr];\n\t\t\t\t\t\tif (x === undefined || x === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ([\"min\", \"max\"].includes(mode)) {\n\t\t\t\t\t\t\tx = parseFloat(x);\n\t\t\t\t\t\t\tif (!isNaN(x)) {\n\t\t\t\t\t\t\t\tthis.val = Math[mode](x, this.val !== null ? this.val : x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmode === \"first\" &&\n\t\t\t\t\t\t\tthis.sorter(x, this.val !== null ? this.val : x) <= 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.val = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmode === \"last\" &&\n\t\t\t\t\t\t\tthis.sorter(x, this.val !== null ? this.val : x) >= 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.val = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\treturn this.val;\n\t\t\t\t\t},\n\t\t\t\t\tformat(x) {\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\treturn x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn formatter(x);\n\t\t\t\t\t},\n\t\t\t\t\tnumInputs: typeof attr !== \"undefined\" ? 0 : 1,\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\tquantile(q, formatter = usFmt) {\n\t\treturn function ([attr]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tvals: [],\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Handle undefined attr gracefully\n\t\t\t\t\t\tif (attr === undefined || attr === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst value = record[attr];\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst x = parseFloat(value);\n\t\t\t\t\t\tif (!isNaN(x)) {\n\t\t\t\t\t\t\tthis.vals.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\tif (this.vals.length === 0) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.vals.sort((a, b) => a - b);\n\t\t\t\t\t\tconst i = (this.vals.length - 1) * q;\n\t\t\t\t\t\treturn (this.vals[Math.floor(i)] + this.vals[Math.ceil(i)]) / 2.0;\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: typeof attr !== \"undefined\" ? 0 : 1,\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\trunningStat(mode = \"mean\", ddof = 1, formatter = usFmt) {\n\t\treturn function ([attr]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tn: 0.0,\n\t\t\t\t\tm: 0.0,\n\t\t\t\t\ts: 0.0,\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Handle undefined attr gracefully\n\t\t\t\t\t\tif (attr === undefined || attr === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst value = record[attr];\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst x = parseFloat(value);\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.n += 1.0;\n\t\t\t\t\t\tif (this.n === 1.0) {\n\t\t\t\t\t\t\tthis.m = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst mNew = this.m + (x - this.m) / this.n;\n\t\t\t\t\t\tthis.s = this.s + (x - this.m) * (x - mNew);\n\t\t\t\t\t\tthis.m = mNew;\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\tif (mode === \"mean\") {\n\t\t\t\t\t\t\tif (this.n === 0) {\n\t\t\t\t\t\t\t\treturn 0 / 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn this.m;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.n <= ddof) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase \"var\":\n\t\t\t\t\t\t\t\treturn this.s / (this.n - ddof);\n\t\t\t\t\t\t\tcase \"stdev\":\n\t\t\t\t\t\t\t\treturn Math.sqrt(this.s / (this.n - ddof));\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error(__(\"unknown mode for runningStat\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: typeof attr !== \"undefined\" ? 0 : 1,\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\tsumOverSum(formatter = usFmt) {\n\t\treturn function ([num, denom]) {\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tsumNum: 0,\n\t\t\t\t\tsumDenom: 0,\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\t// Handle undefined fields gracefully\n\t\t\t\t\t\tif (num !== undefined && num !== null) {\n\t\t\t\t\t\t\tconst numValue = record[num];\n\t\t\t\t\t\t\tif (numValue !== undefined && numValue !== null && !isNaN(parseFloat(numValue))) {\n\t\t\t\t\t\t\t\tthis.sumNum += parseFloat(numValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (denom !== undefined && denom !== null) {\n\t\t\t\t\t\t\tconst denomValue = record[denom];\n\t\t\t\t\t\t\tif (denomValue !== undefined && denomValue !== null && !isNaN(parseFloat(denomValue))) {\n\t\t\t\t\t\t\t\tthis.sumDenom += parseFloat(denomValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\treturn this.sumDenom !== 0 ? this.sumNum / this.sumDenom : 0;\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tnumInputs: 2, // Always requires 2 inputs (numerator and denominator)\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t},\n\n\tfractionOf(wrapped, type = \"total\", formatter = usFmtPct) {\n\t\treturn (...x) => {\n\t\t\t// Create the wrapped aggregator to determine its structure\n\t\t\tconst sampleWrapped = wrapped(...Array.from(x || []));\n\t\t\tconst wrappedNumInputs = sampleWrapped().numInputs;\n\t\t\t\n\t\t\treturn function (data, rowKey, colKey) {\n\t\t\t\treturn {\n\t\t\t\t\tselector: { total: [[], []], row: [rowKey, []], col: [[], colKey] }[\n\t\t\t\t\t\ttype\n\t\t\t\t\t],\n\t\t\t\t\tinner: wrapped(...Array.from(x || []))(data, rowKey, colKey),\n\t\t\t\t\tpush(record) {\n\t\t\t\t\t\tthis.inner.push(record);\n\t\t\t\t\t},\n\t\t\t\t\tformat: formatter,\n\t\t\t\t\tvalue() {\n\t\t\t\t\t\tconst selector = this.selector || [];\n\t\t\t\t\t\tconst totalAggregator = data.getAggregator(...Array.from(selector));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Handle case where getAggregator returns a collection (multiple aggregators)\n\t\t\t\t\t\tlet baseAggregator = totalAggregator;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check if it's a collection (object with multiple aggregators)\n\t\t\t\t\t\tif (totalAggregator && typeof totalAggregator === 'object' && !totalAggregator.inner && !totalAggregator.value) {\n\t\t\t\t\t\t\t// It's a collection, find the base aggregator\n\t\t\t\t\t\t\t// For \"Sum as Fraction of Total\", we need to find \"Sum\" in the collection\n\t\t\t\t\t\t\t// Try common base aggregator names first\n\t\t\t\t\t\t\tconst baseNames = [__(\"Sum\"), __(\"Integer Sum\"), __(\"Count\"), __(\"Average\")];\n\t\t\t\t\t\t\tfor (const baseName of baseNames) {\n\t\t\t\t\t\t\t\tif (totalAggregator[baseName] && typeof totalAggregator[baseName].value === 'function') {\n\t\t\t\t\t\t\t\t\tbaseAggregator = totalAggregator[baseName];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If still not found, try all aggregator names in the collection\n\t\t\t\t\t\t\tif (!baseAggregator || (typeof baseAggregator === 'object' && !baseAggregator.value)) {\n\t\t\t\t\t\t\t\tconst aggregatorNames = data.getAggregatorNames();\n\t\t\t\t\t\t\t\tfor (const aggName of aggregatorNames) {\n\t\t\t\t\t\t\t\t\t// Skip fraction aggregators (they have .inner property)\n\t\t\t\t\t\t\t\t\tif (totalAggregator[aggName] && \n\t\t\t\t\t\t\t\t\t\ttypeof totalAggregator[aggName].value === 'function' &&\n\t\t\t\t\t\t\t\t\t\t!totalAggregator[aggName].inner) {\n\t\t\t\t\t\t\t\t\t\tbaseAggregator = totalAggregator[aggName];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the denominator value\n\t\t\t\t\t\tlet denominatorValue = 0;\n\t\t\t\t\t\tif (baseAggregator) {\n\t\t\t\t\t\t\tif (baseAggregator.inner && typeof baseAggregator.inner.value === 'function') {\n\t\t\t\t\t\t\t\t// It's a wrapped aggregator (like another fractionOf)\n\t\t\t\t\t\t\t\tdenominatorValue = baseAggregator.inner.value();\n\t\t\t\t\t\t\t} else if (typeof baseAggregator.value === 'function') {\n\t\t\t\t\t\t\t\t// It's a base aggregator\n\t\t\t\t\t\t\t\tdenominatorValue = baseAggregator.value();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst numeratorValue = this.inner.value();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (denominatorValue === 0 || denominatorValue === null || denominatorValue === undefined) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn numeratorValue / denominatorValue;\n\t\t\t\t\t},\n\t\t\t\t\tnumInputs: wrappedNumInputs,\n\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t},\n};\n\naggregatorTemplates.countUnique = (f) =>\n\taggregatorTemplates.uniques((x) => x.length, f);\naggregatorTemplates.listUnique = (s) =>\n\taggregatorTemplates.uniques(\n\t\t(x) => x.join(s),\n\t\t(x) => x\n\t);\naggregatorTemplates.max = (f) => aggregatorTemplates.extremes(\"max\", f);\naggregatorTemplates.min = (f) => aggregatorTemplates.extremes(\"min\", f);\naggregatorTemplates.first = (f) => aggregatorTemplates.extremes(\"first\", f);\naggregatorTemplates.last = (f) => aggregatorTemplates.extremes(\"last\", f);\naggregatorTemplates.median = (f) => aggregatorTemplates.quantile(0.5, f);\naggregatorTemplates.average = (f) =>\n\taggregatorTemplates.runningStat(\"mean\", 1, f);\naggregatorTemplates.var = (ddof, f) =>\n\taggregatorTemplates.runningStat(\"var\", ddof, f);\naggregatorTemplates.stdev = (ddof, f) =>\n\taggregatorTemplates.runningStat(\"stdev\", ddof, f);\n\n// default aggregators & renderers use US naming and number formatting\nlet aggregators = ((tpl) => ({\n\t\"Count\": tpl.count(usFmtInt),\n\t\"Count Unique Values\": tpl.countUnique(usFmtInt),\n\t\"List Unique Values\": tpl.listUnique(\", \"),\n\t\"Sum\": tpl.sum(usFmt),\n\t\"Integer Sum\": tpl.sum(usFmtInt),\n\t\"Average\": tpl.average(usFmt),\n\t\"Median\": tpl.median(usFmt),\n\t\"Sample Variance\": tpl.var(1, usFmt),\n\t\"Sample Standard Deviation\": tpl.stdev(1, usFmt),\n\t\"Minimum\": tpl.min(usFmt),\n\t\"Maximum\": tpl.max(usFmt),\n\t\"First\": tpl.first(usFmt),\n\t\"Last\": tpl.last(usFmt),\n\t\"Sum over Sum\": tpl.sumOverSum(usFmt),\n\t\"Sum as Fraction of Total\": tpl.fractionOf(tpl.sum(), \"total\", usFmtPct),\n\t\"Sum as Fraction of Rows\": tpl.fractionOf(tpl.sum(), \"row\", usFmtPct),\n\t\"Sum as Fraction of Columns\": tpl.fractionOf(tpl.sum(), \"col\", usFmtPct),\n\t\"Count as Fraction of Total\": tpl.fractionOf(tpl.count(), \"total\", usFmtPct),\n\t\"Count as Fraction of Rows\": tpl.fractionOf(tpl.count(), \"row\", usFmtPct),\n\t\"Count as Fraction of Columns\": tpl.fractionOf(tpl.count(), \"col\", usFmtPct),\n}))(aggregatorTemplates);\n\nlet translated_aggregators = {};\n\nObject.keys(aggregators).forEach((key) => {\n\ttranslated_aggregators[__(key)] = aggregators[key];\n});\n\naggregators = translated_aggregators;\n\nconst locales = {\n\ten: {\n\t\taggregators,\n\t\tlocaleStrings: {\n\t\t\trenderError: __(\"An error occurred rendering the PivotTable results.\"),\n\t\t\tcomputeError: __(\"An error occurred computing the PivotTable results.\"),\n\t\t\tuiRenderError: __(\"An error occurred rendering the PivotTable UI.\"),\n\t\t\tselectAll: __(\"Select All\"),\n\t\t\tselectNone: __(\"Select None\"),\n\t\t\ttooMany: __(\"(too many to list)\"),\n\t\t\tfilterResults: __(\"Filter values\"),\n\t\t\tapply: __(\"Apply\"),\n\t\t\tcancel: __(\"Cancel\"),\n\t\t\ttotals: __(\"Totals\"),\n\t\t\tvs: __(\"vs\"),\n\t\t\tby: __(\"by\"),\n\t\t},\n\t},\n};\n\n// dateFormat deriver l10n requires month and day names to be passed in directly\nconst mthNamesEn = [\n\t__(\"Jan\"),\n\t__(\"Feb\"),\n\t__(\"Mar\"),\n\t__(\"Apr\"),\n\t__(\"May\"),\n\t__(\"Jun\"),\n\t__(\"Jul\"),\n\t__(\"Aug\"),\n\t__(\"Sep\"),\n\t__(\"Oct\"),\n\t__(\"Nov\"),\n\t__(\"Dec\"),\n];\nconst dayNamesEn = [__(\"Sun\"), __(\"Mon\"), __(\"Tue\"), __(\"Wed\"), __(\"Thu\"), __(\"Fri\"), __(\"Sat\")];\nconst zeroPad = (number) => `0${number}`.substr(-2, 2); // eslint-disable-line no-magic-numbers\n\nconst derivers = {\n\tbin(col, binWidth) {\n\t\treturn (record) => record[col] - (record[col] % binWidth);\n\t},\n\tdateFormat(\n\t\tcol,\n\t\tformatString,\n\t\tutcOutput = false,\n\t\tmthNames = mthNamesEn,\n\t\tdayNames = dayNamesEn\n\t) {\n\t\tconst utc = utcOutput ? \"UTC\" : \"\";\n\t\treturn function (record) {\n\t\t\tconst date = new Date(Date.parse(record[col]));\n\t\t\tif (isNaN(date)) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn formatString.replace(/%(.)/g, function (m, p) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase \"y\":\n\t\t\t\t\t\treturn date[`get${utc}FullYear`]();\n\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\treturn zeroPad(date[`get${utc}Month`]() + 1);\n\t\t\t\t\tcase \"n\":\n\t\t\t\t\t\treturn mthNames[date[`get${utc}Month`]()];\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\treturn zeroPad(date[`get${utc}Date`]());\n\t\t\t\t\tcase \"w\":\n\t\t\t\t\t\treturn dayNames[date[`get${utc}Day`]()];\n\t\t\t\t\tcase \"x\":\n\t\t\t\t\t\treturn date[`get${utc}Day`]();\n\t\t\t\t\tcase \"H\":\n\t\t\t\t\t\treturn zeroPad(date[`get${utc}Hours`]());\n\t\t\t\t\tcase \"M\":\n\t\t\t\t\t\treturn zeroPad(date[`get${utc}Minutes`]());\n\t\t\t\t\tcase \"S\":\n\t\t\t\t\t\treturn zeroPad(date[`get${utc}Seconds`]());\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn `%${p}`;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t},\n};\n\nexport {\n\taggregatorTemplates,\n\taggregators,\n\tderivers,\n\tlocales,\n\tnaturalSort,\n\tnumberFormat,\n\tgetSort,\n\tsortAs\n};","/**\n * Pivot Calculation Engine\n * A clean, correct implementation of the pivot table calculation engine\n * that supports both single and multi-aggregation modes.\n */\n\nimport { aggregators, getSort, naturalSort } from './utils.js';\n\n/**\n * Default props for PivotData\n */\nconst defaultProps = {\n\tdata: [],\n\trows: [],\n\tcols: [],\n\tvals: [],\n\taggregatorName: \"Count\",\n\taggregatorNames: [],\n\taggregatorVals: {},\n\taggregators: aggregators,\n\tvalueFilter: {},\n\tderivedAttributes: {},\n\tsorters: {},\n\trowOrder: \"key_a_to_z\",\n\tcolOrder: \"key_a_to_z\",\n};\n\n/**\n * Create an empty aggregator that returns null/empty values\n */\nfunction makeEmptyAggregator() {\n\treturn {\n\t\tpush() {},\n\t\tvalue() {\n\t\t\treturn null;\n\t\t},\n\t\tformat() {\n\t\t\treturn \"\";\n\t\t},\n\t};\n}\n\n/**\n * Iterate through input records and call callback for each\n * Handles arrays of objects, arrays of arrays, and functions\n */\nexport function forEachRecord(input, derivedAttributes, callback) {\n\tlet addRecord, record;\n\t\n\t// Create a function that applies derived attributes before calling callback\n\tif (Object.getOwnPropertyNames(derivedAttributes).length === 0) {\n\t\taddRecord = callback;\n\t} else {\n\t\taddRecord = function (record) {\n\t\t\tfor (const k in derivedAttributes) {\n\t\t\t\tconst derived = derivedAttributes[k](record);\n\t\t\t\tif (derived !== null) {\n\t\t\t\t\trecord[k] = derived;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn callback(record);\n\t\t};\n\t}\n\n\t// If it's a function, have it call us back\n\tif (typeof input === \"function\") {\n\t\treturn input(addRecord);\n\t} else if (Array.isArray(input)) {\n\t\tif (Array.isArray(input[0])) {\n\t\t\t// array of arrays\n\t\t\tfor (let i = 1; i < input.length; i++) {\n\t\t\t\tconst compactRecord = input[i];\n\t\t\t\trecord = {};\n\t\t\t\tfor (let j = 0; j < input[0].length; j++) {\n\t\t\t\t\tconst k = input[0][j];\n\t\t\t\t\trecord[k] = compactRecord[j];\n\t\t\t\t}\n\t\t\t\taddRecord(record);\n\t\t\t}\n\t\t} else {\n\t\t\t// array of objects\n\t\t\tfor (let i = 0; i < input.length; i++) {\n\t\t\t\trecord = input[i];\n\t\t\t\tif (record && typeof record === \"object\") {\n\t\t\t\t\taddRecord(record);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Pivot Calculation Engine Class\n */\nexport class PivotEngine {\n\tconstructor(inputProps = {}) {\n\t\t// Merge with default props\n\t\tthis.props = Object.assign({}, defaultProps, inputProps);\n\t\t\n\t\t// Resolve aggregator names\n\t\tthis.aggregatorNames = this.resolveAggregatorNames();\n\t\t\n\t\t// Get aggregatorVals if provided\n\t\tconst aggregatorVals = this.props.aggregatorVals || {};\n\t\t\n\t\t// Create aggregator factories for each aggregator name\n\t\tthis.aggregatorFactories = this.aggregatorNames\n\t\t\t.map((name) => {\n\t\t\t\tconst generator = this.props.aggregators[name];\n\t\t\t\tif (typeof generator !== \"function\") {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Use per-aggregator vals if available, otherwise use the shared vals array\n\t\t\t\tconst vals = aggregatorVals[name] || this.props.vals || [];\n\t\t\t\tconst factory = generator(vals);\n\t\t\t\tif (typeof factory !== \"function\") {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn { name, factory };\n\t\t\t})\n\t\t\t.filter(Boolean);\n\n\t\t// Fallback if no valid aggregators found\n\t\tif (!this.aggregatorFactories.length) {\n\t\t\tconst fallbackName = Object.keys(this.props.aggregators)[0];\n\t\t\tif (fallbackName) {\n\t\t\t\tconst aggregatorVals = this.props.aggregatorVals || {};\n\t\t\t\tconst vals = aggregatorVals[fallbackName] || this.props.vals || [];\n\t\t\t\tconst fallbackFactory = this.props.aggregators[fallbackName](vals);\n\t\t\t\tthis.aggregatorFactories.push({\n\t\t\t\t\tname: fallbackName,\n\t\t\t\t\tfactory: fallbackFactory,\n\t\t\t\t});\n\t\t\t\tthis.aggregatorNames = [fallbackName];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Ensure aggregatorNames matches factories\n\t\tthis.aggregatorNames = this.aggregatorFactories.map((entry) => entry.name);\n\t\tthis.primaryAggregatorName = this.aggregatorNames[0] || null;\n\n\t\t// Initialize data structures\n\t\tthis.tree = {};\n\t\tthis.rowKeys = [];\n\t\tthis.colKeys = [];\n\t\tthis.rowTotals = {};\n\t\tthis.colTotals = {};\n\t\tthis.allTotal = this.createAggregatorCollection([], []);\n\t\tthis.sorted = false;\n\n\t\t// Process all records\n\t\tforEachRecord(\n\t\t\tthis.props.data,\n\t\t\tthis.props.derivedAttributes,\n\t\t\t(record) => {\n\t\t\t\tif (this.filter(record)) {\n\t\t\t\t\tthis.processRecord(record);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Resolve aggregator names from props\n\t */\n\tresolveAggregatorNames() {\n\t\tlet names = [];\n\t\tif (Array.isArray(this.props.aggregatorNames) && this.props.aggregatorNames.length) {\n\t\t\tnames = this.props.aggregatorNames.slice();\n\t\t} else if (Array.isArray(this.props.aggregatorName)) {\n\t\t\tnames = this.props.aggregatorName.slice();\n\t\t} else if (typeof this.props.aggregatorName === \"string\" && this.props.aggregatorName) {\n\t\t\tnames = [this.props.aggregatorName];\n\t\t}\n\t\tif (!names.length) {\n\t\t\tconst defaultName = Object.keys(this.props.aggregators)[0];\n\t\t\tif (defaultName) {\n\t\t\t\tnames = [defaultName];\n\t\t\t}\n\t\t}\n\t\t// Remove duplicates\n\t\treturn names.filter((name, index, arr) => arr.indexOf(name) === index);\n\t}\n\n\t/**\n\t * Create a collection of aggregators for a specific row/column combination\n\t */\n\tcreateAggregatorCollection(rowKey, colKey) {\n\t\tconst collection = {};\n\t\tfor (const entry of this.aggregatorFactories) {\n\t\t\tconst { name, factory } = entry;\n\t\t\tcollection[name] = factory(this, rowKey, colKey);\n\t\t}\n\t\tif (!Object.keys(collection).length && this.primaryAggregatorName) {\n\t\t\tcollection[this.primaryAggregatorName] = makeEmptyAggregator();\n\t\t}\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Create an empty collection (for missing cells)\n\t */\n\tcreateEmptyCollection() {\n\t\tconst empty = {};\n\t\tfor (const name of this.aggregatorNames) {\n\t\t\tempty[name] = makeEmptyAggregator();\n\t\t}\n\t\treturn empty;\n\t}\n\n\t/**\n\t * Push a record to all aggregators in a collection\n\t */\n\tpushRecord(collection, record) {\n\t\tif (!collection) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const name in collection) {\n\t\t\tconst aggregator = collection[name];\n\t\t\tif (aggregator && typeof aggregator.push === \"function\") {\n\t\t\t\taggregator.push(record);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filter a record based on valueFilter\n\t * Includes null values in filtering - null values are converted to \"null\" string for consistency\n\t */\n\tfilter(record) {\n\t\tfor (const k in this.props.valueFilter) {\n\t\t\tconst value = record[k];\n\t\t\t// Convert null/undefined to \"null\" string to match how we store them in keys\n\t\t\tconst normalizedValue = value === null || value === undefined || !(k in record) ? \"null\" : value;\n\t\t\tif (normalizedValue in this.props.valueFilter[k]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Process a single record and update all aggregators\n\t */\n\tprocessRecord(record) {\n\t\tconst cols = this.props.cols;\n\t\tconst rows = this.props.rows;\n\t\tconst colKey = [];\n\t\tconst rowKey = [];\n\t\tconst separator = String.fromCharCode(0);\n\t\t\n\t\t// Build column key\n\t\t// Include null values in calculations - convert null/undefined to \"null\" string for consistency\n\t\tfor (let i = 0, len = cols.length; i < len; i++) {\n\t\t\tconst x = cols[i];\n\t\t\tconst value = record[x];\n\t\t\t// Convert null, undefined, or missing fields to \"null\" string for consistent grouping\n\t\t\tcolKey.push(value === null || value === undefined || !(x in record) ? \"null\" : value);\n\t\t}\n\t\t\n\t\t// Build row key\n\t\t// Include null values in calculations - convert null/undefined to \"null\" string for consistency\n\t\tfor (let i = 0, len = rows.length; i < len; i++) {\n\t\t\tconst x = rows[i];\n\t\t\tconst value = record[x];\n\t\t\t// Convert null, undefined, or missing fields to \"null\" string for consistent grouping\n\t\t\trowKey.push(value === null || value === undefined || !(x in record) ? \"null\" : value);\n\t\t}\n\t\t\n\t\tconst flatRowKey = rowKey.join(separator);\n\t\tconst flatColKey = colKey.join(separator);\n\n\t\t// Push to grand total (all data)\n\t\tthis.pushRecord(this.allTotal, record);\n\n\t\t// Push to row totals\n\t\tif (rowKey.length !== 0) {\n\t\t\tif (!this.rowTotals[flatRowKey]) {\n\t\t\t\tthis.rowKeys.push(rowKey);\n\t\t\t\tthis.rowTotals[flatRowKey] = this.createAggregatorCollection(rowKey, []);\n\t\t\t}\n\t\t\tthis.pushRecord(this.rowTotals[flatRowKey], record);\n\t\t}\n\n\t\t// Push to column totals\n\t\tif (colKey.length !== 0) {\n\t\t\tif (!this.colTotals[flatColKey]) {\n\t\t\t\tthis.colKeys.push(colKey);\n\t\t\t\tthis.colTotals[flatColKey] = this.createAggregatorCollection([], colKey);\n\t\t\t}\n\t\t\tthis.pushRecord(this.colTotals[flatColKey], record);\n\t\t}\n\n\t\t// Push to cell (row + column intersection)\n\t\tif (colKey.length !== 0 && rowKey.length !== 0) {\n\t\t\tif (!this.tree[flatRowKey]) {\n\t\t\t\tthis.tree[flatRowKey] = {};\n\t\t\t}\n\t\t\tif (!this.tree[flatRowKey][flatColKey]) {\n\t\t\t\tthis.tree[flatRowKey][flatColKey] = this.createAggregatorCollection(\n\t\t\t\t\trowKey,\n\t\t\t\t\tcolKey\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.pushRecord(this.tree[flatRowKey][flatColKey], record);\n\t\t}\n\t}\n\n\t/**\n\t * Get aggregator collection for a specific row/column combination\n\t */\n\tgetAggregatorCollection(rowKey, colKey) {\n\t\tconst flatRowKey = rowKey.join(String.fromCharCode(0));\n\t\tconst flatColKey = colKey.join(String.fromCharCode(0));\n\t\t\n\t\tlet collection;\n\t\tif (rowKey.length === 0 && colKey.length === 0) {\n\t\t\tcollection = this.allTotal;\n\t\t} else if (rowKey.length === 0) {\n\t\t\tcollection = this.colTotals[flatColKey];\n\t\t} else if (colKey.length === 0) {\n\t\t\tcollection = this.rowTotals[flatRowKey];\n\t\t// Debug: check if row total exists\n\t\tif (!collection) {\n\t\t\t// Row total collection not found\n\t\t}\n\t\t} else {\n\t\t\tcollection =\n\t\t\t\tthis.tree[flatRowKey] && this.tree[flatRowKey][flatColKey]\n\t\t\t\t\t? this.tree[flatRowKey][flatColKey]\n\t\t\t\t\t: null;\n\t\t}\n\t\t\n\t\tif (!collection) {\n\t\t\treturn this.createEmptyCollection();\n\t\t}\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Get a specific aggregator from a row/column combination\n\t * @param {Array} rowKey - Row key array\n\t * @param {Array} colKey - Column key array\n\t * @param {string} aggregatorName - Name of the aggregator to retrieve\n\t * @returns {Object} Aggregator instance\n\t */\n\tgetAggregator(rowKey, colKey, aggregatorName) {\n\t\tconst collection = this.getAggregatorCollection(rowKey, colKey);\n\n\t\t// If aggregatorName is provided, return that specific aggregator\n\t\tif (typeof aggregatorName === \"string\" && aggregatorName) {\n\t\t\t// Try exact match first\n\t\t\tif (collection[aggregatorName]) {\n\t\t\t\treturn collection[aggregatorName];\n\t\t\t}\n\t\t\t// Return empty aggregator if not found\n\t\t\treturn makeEmptyAggregator();\n\t\t}\n\n\t\t// If single aggregator mode, return the first one\n\t\tif (this.aggregatorNames.length === 1) {\n\t\t\tconst name = this.aggregatorNames[0];\n\t\t\treturn collection[name] || makeEmptyAggregator();\n\t\t}\n\n\t\t// Multi-aggregation mode: return the entire collection\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Get list of aggregator names\n\t */\n\tgetAggregatorNames() {\n\t\treturn this.aggregatorNames.slice();\n\t}\n\n\t/**\n\t * Get row keys (sorted)\n\t */\n\tgetRowKeys() {\n\t\tthis.sortKeys();\n\t\treturn this.rowKeys;\n\t}\n\n\t/**\n\t * Get column keys (sorted)\n\t */\n\tgetColKeys() {\n\t\tthis.sortKeys();\n\t\treturn this.colKeys;\n\t}\n\n\t/**\n\t * Create array sort function for attributes\n\t */\n\tarrSort(attrs) {\n\t\tconst sortersArr = [];\n\t\tfor (let i = 0; i < attrs.length; i++) {\n\t\t\tsortersArr.push(getSort(this.props.sorters, attrs[i]));\n\t\t}\n\t\treturn function (a, b) {\n\t\t\tfor (let i = 0; i < sortersArr.length; i++) {\n\t\t\t\tconst sorter = sortersArr[i];\n\t\t\t\tconst comparison = sorter(a[i], b[i]);\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t}\n\n\t/**\n\t * Sort row and column keys based on sorters and order settings\n\t */\n\tsortKeys() {\n\t\tif (this.sorted) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sorted = true;\n\n\t\tconst primary = this.primaryAggregatorName || this.aggregatorNames[0] || null;\n\t\tconst v = (r, c) => {\n\t\t\tconst aggregator = primary\n\t\t\t\t? this.getAggregator(r, c, primary)\n\t\t\t\t: this.getAggregator(r, c);\n\t\t\treturn aggregator && typeof aggregator.value === \"function\"\n\t\t\t\t? aggregator.value()\n\t\t\t\t: null;\n\t\t};\n\n\t\t// Sort row keys\n\t\tswitch (this.props.rowOrder) {\n\t\t\tcase \"value_a_to_z\":\n\t\t\t\tthis.rowKeys.sort((a, b) => naturalSort(v(a, []), v(b, [])));\n\t\t\t\tbreak;\n\t\t\tcase \"value_z_to_a\":\n\t\t\t\tthis.rowKeys.sort((a, b) => -naturalSort(v(a, []), v(b, [])));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.rowKeys.sort(this.arrSort(this.props.rows));\n\t\t}\n\n\t\t// Sort column keys\n\t\tswitch (this.props.colOrder) {\n\t\t\tcase \"value_a_to_z\":\n\t\t\t\tthis.colKeys.sort((a, b) => naturalSort(v([], a), v([], b)));\n\t\t\t\tbreak;\n\t\t\tcase \"value_z_to_a\":\n\t\t\t\tthis.colKeys.sort((a, b) => -naturalSort(v([], a), v([], b)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.colKeys.sort(this.arrSort(this.props.cols));\n\t\t}\n\t}\n}\n\n","// Web Worker for pivot table calculations\nimport { PivotEngine } from '../utils/pivotEngine.js';\nimport { aggregators } from '../utils/utils.js';\n\n// Threshold for using batch processing\nconst BATCH_SIZE = 50000;\n\n// LTTB (Largest-Triangle-Three-Buckets) downsampling algorithm\nfunction lttb(data, threshold) {\n\tif (!data || data.length === 0) return [];\n\tif (threshold >= data.length || threshold < 3) return data;\n\n\t// Convert data to [x, y] format if needed\n\tconst points = data.map((point, index) => {\n\t\tif (Array.isArray(point)) {\n\t\t\treturn { x: point[0], y: point[1], index };\n\t\t} else if (typeof point === 'number') {\n\t\t\treturn { x: index, y: point, index };\n\t\t} else {\n\t\t\treturn { x: point.x || index, y: point.y || point.value || 0, index };\n\t\t}\n\t});\n\n\tconst dataLength = points.length;\n\tconst sampled = [];\n\tconst every = (dataLength - 2) / (threshold - 2);\n\tlet a = 0;\n\tlet nextA = 0;\n\n\tsampled.push(points[a]); // Always include the first point\n\n\tfor (let i = 0; i < threshold - 2; i++) {\n\t\tconst avgRangeStart = Math.floor((i + 1) * every) + 1;\n\t\tconst avgRangeEnd = Math.floor((i + 2) * every) + 1;\n\t\tconst avgRangeLength = avgRangeEnd - avgRangeStart;\n\n\t\tlet avgX = 0;\n\t\tlet avgY = 0;\n\t\tfor (let j = avgRangeStart; j < avgRangeEnd; j++) {\n\t\t\tavgX += points[j].x;\n\t\t\tavgY += points[j].y;\n\t\t}\n\t\tavgX /= avgRangeLength;\n\t\tavgY /= avgRangeLength;\n\n\t\tconst rangeOffs = Math.floor((i + 0) * every) + 1;\n\t\tconst rangeTo = Math.floor((i + 1) * every) + 1;\n\t\tconst pointAX = points[a].x;\n\t\tconst pointAY = points[a].y;\n\n\t\tlet maxArea = -1;\n\t\tfor (let j = rangeOffs; j < rangeTo; j++) {\n\t\t\tconst area = Math.abs(\n\t\t\t\t(pointAX - avgX) * (points[j].y - pointAY) -\n\t\t\t\t(pointAX - points[j].x) * (avgY - pointAY)\n\t\t\t);\n\t\t\tif (area > maxArea) {\n\t\t\t\tmaxArea = area;\n\t\t\t\tnextA = j;\n\t\t\t}\n\t\t}\n\n\t\tsampled.push(points[nextA]);\n\t\ta = nextA;\n\t}\n\n\tsampled.push(points[dataLength - 1]); // Always include the last point\n\n\t// Convert back to original format\n\treturn sampled.map(point => {\n\t\tif (Array.isArray(data[0])) {\n\t\t\treturn [point.x, point.y];\n\t\t}\n\t\tif (typeof data[0] === 'number') {\n\t\t\treturn point.y;\n\t\t}\n\t\treturn { x: point.x, y: point.y };\n\t});\n}\n\n// Apply LTTB to chart data\nfunction optimizeChartDataWithLTTB(chartData, maxPoints = 500) {\n\tif (!chartData || !chartData.labels || !chartData.datasets) {\n\t\treturn chartData;\n\t}\n\n\tconst { labels, datasets } = chartData;\n\tconst dataLength = labels.length;\n\tif (dataLength <= maxPoints) {\n\t\treturn chartData;\n\t}\n\n\t// Apply LTTB to each dataset\n\tconst optimizedDatasets = datasets.map(dataset => {\n\t\tconst dataPoints = labels.map((label, index) => ({\n\t\t\tx: index,\n\t\t\ty: typeof dataset.values[index] === 'number' \n\t\t\t\t? dataset.values[index] \n\t\t\t\t: (parseFloat(dataset.values[index]) || 0)\n\t\t}));\n\n\t\tconst downsampled = lttb(dataPoints, maxPoints);\n\t\tconst downsampledIndices = downsampled.map(point => point.x);\n\t\tconst optimizedLabels = downsampledIndices.map(idx => labels[idx]);\n\t\tconst optimizedValues = downsampled.map(point => point.y);\n\n\t\treturn {\n\t\t\t...dataset,\n\t\t\tvalues: optimizedValues\n\t\t};\n\t});\n\n\t// Use the labels from the first dataset\n\tconst firstDatasetIndices = labels.map((_, index) => index);\n\tconst downsampledFirst = lttb(\n\t\tfirstDatasetIndices.map(idx => ({ x: idx, y: 0 })),\n\t\tmaxPoints\n\t);\n\tconst optimizedLabels = downsampledFirst.map(point => labels[point.x]);\n\n\treturn {\n\t\tlabels: optimizedLabels,\n\t\tdatasets: optimizedDatasets\n\t};\n}\n\nself.onmessage = async (e) => {\n\tconst { id, type, payload } = e.data;\n\n\tif (type === 'CALCULATE_PIVOT') {\n\t\ttry {\n\t\t\tconst { data, rows, cols, vals, aggregatorNames, aggregatorVals, valueFilter, derivedAttributes, sorters, rowOrder, colOrder } = payload;\n\n\t\t\t// Create PivotEngine instance in worker\n\t\t\tconst pivotData = new PivotEngine({\n\t\t\t\tdata,\n\t\t\t\trows,\n\t\t\t\tcols,\n\t\t\t\tvals,\n\t\t\t\taggregatorNames,\n\t\t\t\taggregatorVals,\n\t\t\t\taggregators, // Pass aggregators to worker\n\t\t\t\tvalueFilter,\n\t\t\t\tderivedAttributes: {}, // Functions can't be serialized, so use empty object\n\t\t\t\tsorters: {}, // Functions can't be serialized, so use empty object\n\t\t\t\trowOrder,\n\t\t\t\tcolOrder\n\t\t\t});\n\n\t\t\t// Extract necessary data for rendering\n\t\t\tconst rowKeys = pivotData.getRowKeys();\n\t\t\tconst colKeys = pivotData.getColKeys();\n\t\t\tconst aggregatorNamesList = pivotData.getAggregatorNames();\n\n\t\t\t// Build result structure\n\t\t\tconst result = {\n\t\t\t\trowKeys,\n\t\t\t\tcolKeys,\n\t\t\t\taggregatorNames: aggregatorNamesList,\n\t\t\t\ttree: {},\n\t\t\t\trowTotals: {},\n\t\t\t\tcolTotals: {},\n\t\t\t\tallTotal: {}\n\t\t\t};\n\n\t\t\t// Populate tree with aggregated values\n\t\t\tfor (const rowKey of rowKeys) {\n\t\t\t\tconst flatRowKey = rowKey.join(String.fromCharCode(0));\n\t\t\t\tresult.tree[flatRowKey] = {};\n\t\t\t\tfor (const colKey of colKeys) {\n\t\t\t\t\tconst flatColKey = colKey.join(String.fromCharCode(0));\n\t\t\t\t\tresult.tree[flatRowKey][flatColKey] = {};\n\t\t\t\t\tfor (const aggName of aggregatorNamesList) {\n\t\t\t\t\t\tconst aggregator = pivotData.getAggregator(rowKey, colKey, aggName);\n\t\t\t\t\t\tconst value = aggregator && typeof aggregator.value === 'function' ? aggregator.value() : null;\n\t\t\t\t\t\tconst formatted = aggregator && typeof aggregator.format === 'function' ? aggregator.format(value) : (value !== null && value !== undefined ? String(value) : '');\n\t\t\t\t\t\tresult.tree[flatRowKey][flatColKey][aggName] = { value, formatted };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Populate row totals\n\t\t\tfor (const rowKey of rowKeys) {\n\t\t\t\tconst flatRowKey = rowKey.join(String.fromCharCode(0));\n\t\t\t\tresult.rowTotals[flatRowKey] = {};\n\t\t\t\tfor (const aggName of aggregatorNamesList) {\n\t\t\t\t\tconst aggregator = pivotData.getAggregator(rowKey, [], aggName);\n\t\t\t\t\tif (aggregator && typeof aggregator.value === 'function') {\n\t\t\t\t\t\tconst value = aggregator.value();\n\t\t\t\t\t\t// Debug: log for List Unique Values to see what value we're getting\n\t\t\t\t\tconst cleanAggName = aggName.split('(')[0].trim().toLowerCase();\n\t\t\t\t\tif (cleanAggName.includes('list') && cleanAggName.includes('unique')) {\n\t\t\t\t\t\t// Debug info for List Unique Values aggregator\n\t\t\t\t\t}\n\t\t\t\t\t\t// For \"List Unique Values\", ensure we get the raw value (comma-separated string)\n\t\t\t\t\t\t// The format function should just return the value as-is\n\t\t\t\t\t\tconst formatted = aggregator && typeof aggregator.format === 'function' ? aggregator.format(value) : (value !== null && value !== undefined ? String(value) : '');\n\t\t\t\t\t\tresult.rowTotals[flatRowKey][aggName] = { value, formatted };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.rowTotals[flatRowKey][aggName] = { value: null, formatted: '' };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Populate column totals\n\t\t\tfor (const colKey of colKeys) {\n\t\t\t\tconst flatColKey = colKey.join(String.fromCharCode(0));\n\t\t\t\tresult.colTotals[flatColKey] = {};\n\t\t\t\tfor (const aggName of aggregatorNamesList) {\n\t\t\t\t\tconst aggregator = pivotData.getAggregator([], colKey, aggName);\n\t\t\t\t\tconst value = aggregator && typeof aggregator.value === 'function' ? aggregator.value() : null;\n\t\t\t\t\tconst formatted = aggregator && typeof aggregator.format === 'function' ? aggregator.format(value) : (value !== null && value !== undefined ? String(value) : '');\n\t\t\t\t\tresult.colTotals[flatColKey][aggName] = { value, formatted };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Populate grand total\n\t\t\tfor (const aggName of aggregatorNamesList) {\n\t\t\t\tconst aggregator = pivotData.getAggregator([], [], aggName);\n\t\t\t\tconst value = aggregator && typeof aggregator.value === 'function' ? aggregator.value() : null;\n\t\t\t\tconst formatted = aggregator && typeof aggregator.format === 'function' ? aggregator.format(value) : (value !== null && value !== undefined ? String(value) : '');\n\t\t\t\tresult.allTotal[aggName] = { value, formatted };\n\t\t\t}\n\n\t\tself.postMessage({ id, type: 'PIVOT_CALCULATED', result });\n\t} catch (error) {\n\t\tself.postMessage({ id, type: 'ERROR', error: error.message, stack: error.stack });\n\t\t}\n\t} else if (type === 'OPTIMIZE_CHART_DATA') {\n\t\ttry {\n\t\t\tconst { chartData, chartType, lttbThreshold } = payload;\n\t\t\t\n\t\t\t// Apply LTTB for line/bar charts\n\t\t\tif ((chartType === 'line' || chartType === 'bar') && chartData && chartData.labels && chartData.labels.length > lttbThreshold) {\n\t\t\t\tconst optimized = optimizeChartDataWithLTTB(chartData, lttbThreshold);\n\t\t\t\tself.postMessage({ id, type: 'CHART_DATA_OPTIMIZED', chartData: optimized });\n\t\t\t} else {\n\t\t\t\t// No optimization needed, return as-is\n\t\t\t\tself.postMessage({ id, type: 'CHART_DATA_OPTIMIZED', chartData });\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tself.postMessage({ id, type: 'ERROR', error: error.message, stack: error.stack });\n\t\t}\n\t}\n};\n\n"],"names":["__","text","args","match","index","addSeparators","nStr","thousandsSep","decimalSep","x","x1","x2","rgx","getFormatOptionsFromFrappe","format","format_info","numberFormat","optsIn","frappeFormat","defaults","opts","result","rx","rd","rz","naturalSort","as","bs","nas","nbs","a","b","a1","b1","getSort","sorters","attr","sort","usFmt","usFmtInt","usFmtPct","aggregatorTemplates","formatter","data","rowKey","colKey","fn","attrName","record","value","isUnique","i","existing","mode","q","ddof","mNew","num","denom","numValue","denomValue","wrapped","type","wrappedNumInputs","selector","totalAggregator","baseAggregator","baseNames","baseName","aggregatorNames","aggName","denominatorValue","numeratorValue","f","s","aggregators","tpl","translated_aggregators","key","defaultProps","makeEmptyAggregator","forEachRecord","input","derivedAttributes","callback","addRecord","k","derived","compactRecord","j","PivotEngine","inputProps","aggregatorVals","name","generator","vals","factory","fallbackName","fallbackFactory","entry","names","defaultName","arr","collection","empty","aggregator","cols","rows","separator","len","flatRowKey","flatColKey","aggregatorName","attrs","sortersArr","sorter","comparison","primary","v","c","lttb","threshold","points","point","dataLength","sampled","every","nextA","avgRangeStart","avgRangeEnd","avgRangeLength","avgX","avgY","rangeOffs","rangeTo","pointAX","pointAY","maxArea","area","optimizeChartDataWithLTTB","chartData","maxPoints","labels","datasets","optimizedDatasets","dataset","dataPoints","label","downsampled","idx","optimizedValues","firstDatasetIndices","_","e","id","payload","valueFilter","rowOrder","colOrder","pivotData","rowKeys","colKeys","aggregatorNamesList","formatted","cleanAggName","error","chartType","lttbThreshold","optimized"],"mappings":"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"}